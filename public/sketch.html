<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>p5</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.3.1/p5.js"></script>
    <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.3.1/addons/p5.sound.min.js"></script> -->
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
      }
      canvas {
        display: block;
      }
    </style>
  </head>

  <body>
    <script>
      // iframeからのメッセージをリッスンする
      window.addEventListener('message', (event) => {
        const _fragCode = event.data;
        const _shader = createShader(vertCode, _fragCode);
        shader(_shader);

        // shaderのコンパイルエラー取得
        // 0.1秒待つ
        // await new Promise((resolve) => setTimeout(resolve, 1000));
        setTimeout(() => {
          const gl = _shader._renderer.GL;
          const frag_compile_status = gl.getShaderParameter(
            _shader._fragShader,
            gl.COMPILE_STATUS
          );
          if (frag_compile_status == false) {
            window.parent.postMessage('failed', '*');
          } else {
            window.parent.postMessage('success', '*');
            myShaders.push(_shader);
            // randomVals.push(Math.random());
            _shader.setUniform('u_random', Math.random());
          }
        }, 1000);
      });

      // let myShader;
      let myShaders = [];
      let noiseVal = 0.0;
      const randomVals = [];

      const vertCode = `
        precision highp float;
        // p5.jsのデフォルトの頂点位置属性
        attribute vec3 aPosition;
        void main() {
          gl_Position = vec4(aPosition, 1.0);
        }
      `;
      const fragCode = `
        precision highp float;
        uniform float u_time;
        void main() {
          vec3 color = vec3(sin(u_time) * 0.5 + 0.5, 0, 0);
          gl_FragColor = vec4(color, 1.0);
        }
      `;
      const fragCode2 = `
        precision highp float;
        uniform float u_time;
        void main() {
          vec3 color = vec3(0, sin(u_time) * 0.5 + 0.5, 0);
          gl_FragColor = vec4(color, 1.0);
        }
      `;

      function setup() {
        createCanvas(windowWidth, windowHeight, WEBGL);

        // test
        // let tempShader = createShader(vertCode, fragCode);
        // myShaders.push(tempShader);
        // tempShader = createShader(vertCode, fragCode2);
        // myShaders.push(tempShader);
        // tempShader = createShader(vertCode, fragCode);
        // myShaders.push(tempShader);
      }

      function draw() {
        // background(220);

        // translate(-width / 2, -height / 2);
        noStroke();
        if (myShaders.length == 0) return;

        const m = millis();

        noiseVal = noise(m / 5000.0);
        const rangeLength = 2; // 1から-1までの長さ
        const interval = rangeLength / myShaders.length; // 間隔
        for (let i = 0; i < myShaders.length; i++) {
          const cShader = myShaders[myShaders.length - i - 1];
          cShader.setUniform('u_time', m / 1000.0);
          cShader.setUniform('u_noise', noiseVal);

          shader(cShader);
          quad(
            -1,
            -(1 - interval * i),
            -1,
            -(1 - interval * i) + interval,
            1,
            -(1 - interval * i) + interval,
            1,
            -(1 - interval * i)
          );
          // resetShader();
        }
        resetShader();
      }

      function windowResized() {
        resizeCanvas(windowWidth, windowHeight);
      }
    </script>
  </body>
</html>
